#!/bin/bash
# Secure Database Configuration Script for MCP Ecosystem
# Implements strong passwords and security best practices for Neo4j and Redis

set -e

echo "ðŸ” MCP Database Security Configuration"
echo "======================================"

# Generate strong passwords if not provided
REDIS_PASSWORD=${REDIS_PASSWORD:-$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-25)}
NEO4J_PASSWORD=${NEO4J_PASSWORD:-$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-25)}
NEO4J_USER=${NEO4J_USER:-"neo4j"}

echo "ðŸ“‹ Security Configuration:"
echo "  Redis Password: [HIDDEN]"
echo "  Neo4j User: $NEO4J_USER"
echo "  Neo4j Password: [HIDDEN]"
echo ""

# Function to secure Redis
secure_redis() {
    echo "ðŸ”’ Securing Redis..."
    
    # Create Redis configuration
    cat > redis.conf << EOF
# Redis Security Configuration
# Generated by secure_databases.sh

# Network Security
bind 127.0.0.1 ::1
protected-mode yes
port 6379

# Authentication
requirepass $REDIS_PASSWORD

# Persistence
save 900 1
save 300 10
save 60 10000
stop-writes-on-bgsave-error yes
rdbcompression yes
rdbchecksum yes
dbfilename dump.rdb
dir /data

# Logging
loglevel notice
logfile /var/log/redis/redis-server.log
syslog-enabled yes
syslog-ident redis

# Security Limits
maxclients 10000
maxmemory 2gb
maxmemory-policy allkeys-lru

# Disable Dangerous Commands
rename-command FLUSHDB ""
rename-command FLUSHALL ""
rename-command KEYS ""
rename-command CONFIG "CONFIG_$REDIS_PASSWORD"
rename-command SHUTDOWN "SHUTDOWN_$REDIS_PASSWORD"

# SSL/TLS Configuration (optional)
# tls-port 6380
# tls-cert-file /path/to/redis.crt
# tls-key-file /path/to/redis.key
# tls-ca-cert-file /path/to/ca.crt
# tls-dh-params-file /path/to/redis.dh

# ACL Configuration
aclfile /etc/redis/users.acl
EOF

    # Create ACL file for Redis 6+
    cat > redis_users.acl << EOF
# Redis ACL Configuration
# Default user with full access (for backward compatibility)
user default on +@all ~* &* >$REDIS_PASSWORD

# Read-only user for monitoring
user monitoring on +ping +info +config|get +client|list +latency ~* &* >monitoring_$REDIS_PASSWORD

# Application user with limited access
user app on +@read +@write +@list +@set +@sortedset +@hash +@stream -@dangerous ~* &* >app_$REDIS_PASSWORD

# Backup user
user backup on +bgsave +lastsave +info +config|get ~* &* >backup_$REDIS_PASSWORD
EOF

    # Update Docker Compose for Redis
    cat > redis-docker-update.yml << EOF
  redis:
    image: redis:7-alpine
    container_name: mcp_redis
    restart: always
    command: redis-server /usr/local/etc/redis/redis.conf
    volumes:
      - ./redis.conf:/usr/local/etc/redis/redis.conf:ro
      - ./redis_users.acl:/etc/redis/users.acl:ro
      - redis_data:/data
      - redis_logs:/var/log/redis
    environment:
      - REDIS_REPLICATION_MODE=master
    ulimits:
      nofile:
        soft: 65535
        hard: 65535
    sysctls:
      - net.core.somaxconn=1024
EOF

    echo "âœ… Redis security configuration created"
}

# Function to secure Neo4j
secure_neo4j() {
    echo "ðŸ”’ Securing Neo4j..."
    
    # Create Neo4j configuration
    cat > neo4j.conf << EOF
# Neo4j Security Configuration
# Generated by secure_databases.sh

# Network connector configuration
dbms.default_listen_address=0.0.0.0
dbms.connector.bolt.enabled=true
dbms.connector.bolt.listen_address=:7687
dbms.connector.http.enabled=true
dbms.connector.http.listen_address=:7474
dbms.connector.https.enabled=true
dbms.connector.https.listen_address=:7473

# SSL/TLS Configuration
dbms.ssl.policy.bolt.enabled=true
dbms.ssl.policy.bolt.base_directory=certificates/bolt
dbms.ssl.policy.bolt.private_key=private.key
dbms.ssl.policy.bolt.public_certificate=public.crt
dbms.ssl.policy.bolt.client_auth=OPTIONAL

dbms.ssl.policy.https.enabled=true
dbms.ssl.policy.https.base_directory=certificates/https
dbms.ssl.policy.https.private_key=private.key
dbms.ssl.policy.https.public_certificate=public.crt

# Security settings
dbms.security.auth_enabled=true
dbms.security.auth_lock_time=5s
dbms.security.auth_max_failed_attempts=3
dbms.security.procedures.unrestricted=algo.*,apoc.*
dbms.security.allow_csv_import_from_file_urls=false

# Authentication and authorization
dbms.security.auth_provider=native
dbms.security.auth_cache_max_capacity=10000
dbms.security.auth_cache_ttl=10m

# Query execution limits
dbms.transaction.timeout=30s
dbms.transaction.concurrent.maximum=1000
cypher.lenient_create_relationship=false
cypher.forbid_exhaustive_shortestpath=true

# Memory configuration
dbms.memory.heap.initial_size=512m
dbms.memory.heap.max_size=2g
dbms.memory.pagecache.size=1g

# Logging
dbms.logs.query.enabled=true
dbms.logs.query.threshold=500ms
dbms.logs.query.rotation.keep_number=7
dbms.logs.query.rotation.size=20m
dbms.logs.security.level=INFO

# Backup
dbms.backup.enabled=true
dbms.backup.listen_address=:6362
EOF

    # Create security initialization script
    cat > init_neo4j_security.cypher << EOF
// Neo4j Security Initialization Script

// Create role-based access control
CREATE ROLE reader;
CREATE ROLE writer;
CREATE ROLE admin;

// Grant permissions to roles
GRANT MATCH {*} ON GRAPH * TO reader;
GRANT MATCH {*} ON GRAPH * TO writer;
GRANT CREATE ON GRAPH * TO writer;
GRANT SET PROPERTY {*} ON GRAPH * TO writer;
GRANT ALL ON GRAPH * TO admin;
GRANT ALL ON DATABASE * TO admin;

// Create users with roles
CREATE USER app_reader SET PASSWORD '$NEO4J_PASSWORD' SET PASSWORD CHANGE NOT REQUIRED;
CREATE USER app_writer SET PASSWORD '$NEO4J_PASSWORD' SET PASSWORD CHANGE NOT REQUIRED;
CREATE USER backup SET PASSWORD 'backup_$NEO4J_PASSWORD' SET PASSWORD CHANGE NOT REQUIRED;
CREATE USER monitoring SET PASSWORD 'monitoring_$NEO4J_PASSWORD' SET PASSWORD CHANGE NOT REQUIRED;

// Assign roles to users
GRANT ROLE reader TO app_reader;
GRANT ROLE writer TO app_writer;
GRANT ROLE reader TO backup;
GRANT ROLE reader TO monitoring;

// Create indexes for security audit
CREATE INDEX user_activity_idx FOR (n:UserActivity) ON (n.timestamp);
CREATE INDEX security_event_idx FOR (n:SecurityEvent) ON (n.event_type, n.timestamp);

// Enable query logging for security audit
CALL dbms.setConfigValue('dbms.logs.query.enabled', 'true');
CALL dbms.setConfigValue('dbms.logs.query.parameter_logging_enabled', 'true');
EOF

    # Update Docker Compose for Neo4j
    cat > neo4j-docker-update.yml << EOF
  neo4j:
    image: neo4j:5-enterprise
    container_name: mcp_neo4j
    restart: always
    environment:
      - NEO4J_AUTH=$NEO4J_USER/$NEO4J_PASSWORD
      - NEO4J_ACCEPT_LICENSE_AGREEMENT=yes
      - NEO4J_dbms_mode=SINGLE
      - NEO4J_dbms_security_procedures_unrestricted=algo.*,apoc.*
      - NEO4J_dbms_security_auth__minimum__password__length=12
      - NEO4J_dbms_logs_query_enabled=true
      - NEO4J_dbms_logs_query_threshold=500ms
      - NEO4J_dbms_memory_pagecache_size=1G
      - NEO4J_dbms_memory_heap_initial__size=512M
      - NEO4J_dbms_memory_heap_max__size=2G
    volumes:
      - ./neo4j.conf:/conf/neo4j.conf:ro
      - neo4j_data:/data
      - neo4j_logs:/logs
      - neo4j_import:/var/lib/neo4j/import
      - neo4j_plugins:/plugins
      - ./certificates:/var/lib/neo4j/certificates:ro
    ulimits:
      nofile:
        soft: 65535
        hard: 65535
EOF

    echo "âœ… Neo4j security configuration created"
}

# Function to create SSL certificates
create_certificates() {
    echo "ðŸ” Creating SSL certificates..."
    
    mkdir -p certificates/{bolt,https,redis}
    
    # Generate CA certificate
    openssl req -new -x509 -days 3650 -nodes \
        -out certificates/ca.crt \
        -keyout certificates/ca.key \
        -subj "/C=US/ST=State/L=City/O=InsightPulseAI/CN=MCP-CA"
    
    # Generate certificates for each service
    for service in bolt https redis; do
        # Generate private key
        openssl genrsa -out certificates/$service/private.key 4096
        
        # Generate certificate request
        openssl req -new \
            -key certificates/$service/private.key \
            -out certificates/$service/request.csr \
            -subj "/C=US/ST=State/L=City/O=InsightPulseAI/CN=mcp-$service"
        
        # Sign certificate with CA
        openssl x509 -req -days 3650 \
            -in certificates/$service/request.csr \
            -CA certificates/ca.crt \
            -CAkey certificates/ca.key \
            -CAcreateserial \
            -out certificates/$service/public.crt
        
        # Clean up
        rm certificates/$service/request.csr
        
        # Set permissions
        chmod 600 certificates/$service/private.key
        chmod 644 certificates/$service/public.crt
    done
    
    echo "âœ… SSL certificates created"
}

# Function to update environment file
update_env_file() {
    echo "ðŸ“ Updating environment configuration..."
    
    # Backup existing .env file
    if [ -f .env.production ]; then
        cp .env.production .env.production.backup.$(date +%Y%m%d_%H%M%S)
    fi
    
    # Update or create .env.production
    cat > .env.production << EOF
# MCP Database Security Configuration
# Generated by secure_databases.sh
# Created: $(date)

# Redis Security
REDIS_PASSWORD=$REDIS_PASSWORD
REDIS_URL=redis://:$REDIS_PASSWORD@redis:6379
REDIS_TLS_ENABLED=false
REDIS_MAX_CLIENTS=10000
REDIS_MAX_MEMORY=2gb

# Neo4j Security  
NEO4J_USER=$NEO4J_USER
NEO4J_PASSWORD=$NEO4J_PASSWORD
NEO4J_AUTH=$NEO4J_USER/$NEO4J_PASSWORD
NEO4J_URI=bolt://neo4j:7687
NEO4J_ENCRYPTED=true
NEO4J_TRUST=TRUST_SYSTEM_CA_SIGNED_CERTIFICATES

# Connection Pool Settings
NEO4J_MAX_CONNECTION_LIFETIME=3600000
NEO4J_MAX_CONNECTION_POOL_SIZE=100
NEO4J_CONNECTION_ACQUISITION_TIMEOUT=60000

# Security Settings
ENABLE_SSL=true
ENFORCE_AUTH=true
SESSION_TIMEOUT=1800
MAX_LOGIN_ATTEMPTS=3
LOCKOUT_DURATION=300

# Backup Configuration
BACKUP_ENCRYPTION_KEY=$(openssl rand -hex 32)
BACKUP_RETENTION_DAYS=30
EOF

    # Create secrets file with restricted permissions
    cat > .secrets << EOF
# MCP Secret Credentials
# PROTECT THIS FILE - DO NOT COMMIT TO VERSION CONTROL

REDIS_ADMIN_PASSWORD=$REDIS_PASSWORD
REDIS_APP_PASSWORD=app_$REDIS_PASSWORD
REDIS_MONITORING_PASSWORD=monitoring_$REDIS_PASSWORD
REDIS_BACKUP_PASSWORD=backup_$REDIS_PASSWORD

NEO4J_ADMIN_PASSWORD=$NEO4J_PASSWORD
NEO4J_APP_READER_PASSWORD=$NEO4J_PASSWORD
NEO4J_APP_WRITER_PASSWORD=$NEO4J_PASSWORD
NEO4J_BACKUP_PASSWORD=backup_$NEO4J_PASSWORD
NEO4J_MONITORING_PASSWORD=monitoring_$NEO4J_PASSWORD
EOF

    chmod 600 .secrets
    
    echo "âœ… Environment configuration updated"
}

# Function to test database connections
test_connections() {
    echo "ðŸ§ª Testing database connections..."
    
    # Test Redis connection
    echo -n "Testing Redis connection... "
    if docker exec mcp_redis redis-cli -a "$REDIS_PASSWORD" ping > /dev/null 2>&1; then
        echo "âœ… Success"
    else
        echo "âŒ Failed"
    fi
    
    # Test Neo4j connection
    echo -n "Testing Neo4j connection... "
    if docker exec mcp_neo4j cypher-shell -u "$NEO4J_USER" -p "$NEO4J_PASSWORD" "RETURN 1" > /dev/null 2>&1; then
        echo "âœ… Success"
    else
        echo "âŒ Failed"
    fi
}

# Function to create security monitoring script
create_monitoring_script() {
    echo "ðŸ“Š Creating security monitoring script..."
    
    cat > monitor_db_security.sh << 'EOF'
#!/bin/bash
# Database Security Monitoring Script

echo "ðŸ” Database Security Monitor"
echo "==========================="
echo "Timestamp: $(date)"
echo ""

# Check Redis security
echo "Redis Security Status:"
docker exec mcp_redis redis-cli -a "$REDIS_PASSWORD" INFO server | grep -E "redis_version|tcp_port|config_file"
docker exec mcp_redis redis-cli -a "$REDIS_PASSWORD" CONFIG GET "requirepass" | grep -v requirepass
docker exec mcp_redis redis-cli -a "$REDIS_PASSWORD" ACL LIST 2>/dev/null || echo "ACL not available"
echo ""

# Check Neo4j security
echo "Neo4j Security Status:"
docker exec mcp_neo4j cypher-shell -u "$NEO4J_USER" -p "$NEO4J_PASSWORD" \
    "SHOW USERS" 2>/dev/null || echo "Unable to show users"
docker exec mcp_neo4j cypher-shell -u "$NEO4J_USER" -p "$NEO4J_PASSWORD" \
    "SHOW ROLES" 2>/dev/null || echo "Unable to show roles"
echo ""

# Check failed authentication attempts
echo "Recent Authentication Failures:"
docker logs mcp_redis 2>&1 | grep -i "auth\|password" | tail -5
docker logs mcp_neo4j 2>&1 | grep -i "auth\|failed" | tail -5
echo ""

# Check resource usage
echo "Resource Usage:"
docker stats --no-stream mcp_redis mcp_neo4j
EOF

    chmod +x monitor_db_security.sh
    
    echo "âœ… Security monitoring script created"
}

# Main execution
main() {
    echo "Starting database security configuration..."
    
    # Create necessary directories
    mkdir -p certificates redis_logs neo4j_logs
    
    # Run security configurations
    secure_redis
    secure_neo4j
    create_certificates
    update_env_file
    create_monitoring_script
    
    # Apply configurations
    echo ""
    echo "ðŸ“‹ Apply these configurations:"
    echo "1. Update docker-compose.yml with the generated configurations"
    echo "2. Copy certificates to the appropriate directories"
    echo "3. Restart database services: docker-compose restart redis neo4j"
    echo "4. Run init script: docker exec mcp_neo4j cypher-shell -u $NEO4J_USER -p [password] < init_neo4j_security.cypher"
    echo ""
    echo "ðŸ” Security Credentials:"
    echo "Redis Password: Saved in .secrets file"
    echo "Neo4j Password: Saved in .secrets file"
    echo ""
    echo "âš ï¸  IMPORTANT:"
    echo "1. Store .secrets file securely and never commit it"
    echo "2. Backup these credentials in a secure password manager"
    echo "3. Rotate passwords every 90 days"
    echo "4. Monitor logs regularly for suspicious activity"
    echo "5. Test connections: ./monitor_db_security.sh"
}

# Run main function
main